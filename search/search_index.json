{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#hello-world","title":"Hello, World! \ud83d\udc4b:","text":"<p>Welcome to my LeetCode Documentation Progress Page! Here, I track my progress on coding challenges, focusing on the problems I'm tackling and the lessons I'm learning. This page helps me stay organized and deepen my understanding of algorithms and data structures. Feel free to explore my journey :) </p>"},{"location":"#site-navigation","title":"Site Navigation:","text":"Method Description <code>Top 150 interview questions</code> :material-check: <code>Blind 75 questions</code> :material-check-all: <code>DSA conceptual</code> :material-close:"},{"location":"Index7/","title":"Strings","text":""},{"location":"Index7/#string-in-java-introduction","title":"String in java: Introduction Why Are Strings Immutable?  String Methods:  StringBuilder in Java","text":"<p>Two Ways to Construct Strings: </p> <ul> <li> <p>String Literal:</p> <ul> <li>Example: <code>String message = \"Hello there\";</code></li> <li>When created this way, the string is stored in the String Constant Pool, which optimizes memory usage by reusing string literals.</li> </ul> </li> <li> <p>Using New Keyword:</p> <ul> <li>Example: <code>String name = new String(\"ABCDEF\");</code></li> <li>This method directly allocates memory for the string object in the Heap Memory, which can lead to more memory usage compared to string literals.</li> </ul> </li> </ul> <p> A string is an immutable object, meaning we cannot change it after creating the instance. It is similar to \"final\" primitive types. Whenever we modify a string, a new instance is created. </p> <p><code>length(), substring(startIndex, endIndex), concat(string), charAt(index), equals(string), indexOf(substring), toUpperCase(), toLowerCase(), trim(), contains(substring)</code></p> <pre><code>graph LR;\n    subgraph Heap\n        subgraph String Common Pool\n            A[\"Hello\"]\n        end\n    end\n\n    s1 --&gt; A;\n    s2 --&gt; A;\n    s3 --&gt; A;</code></pre> <pre><code>    // Changing the value of s1\n    s1 = \"Java\";\n\n    // Updating with concat() operation\n    s2.concat(\" World\");\n\n    // The concatenated String will be created as a new instance\n    // An object should refer to that instance to get the concatenated value.\n    String newString = s3.concat(\"Hello There\");\n</code></pre> <pre><code>graph LR;\n    subgraph Heap\n        subgraph String Common Pool\n            A[\"Hello\"]\n            B[\"Java\"]\n            D[\"Hello There\"]\n            E[\"Hello World (Unreferenced)\"]  \n        end\n    end\n\n    s1 --&gt; B\n    s2 --&gt; A\n    s3 --&gt; A\n    newString --&gt; D</code></pre> <p>Explanation:</p> <ol> <li>When s1 is assigned a new value, it references a new string instance, \"Java.\" The original string \"Hello\" remains unchanged.</li> <li>The concat() operation creates a new string instance without modifying the original string. In the case of s2.concat(\" World\"), the result is a new string \"Hello World,\" but since it is not assigned to any variable, it becomes unreferenced.</li> <li>On the other hand, newString is assigned the result of s3.concat(\" There\"), which means newString now points to the new string instance \"Hello There.\"</li> </ol> <ul> <li> <p>Definition: A <code>StringBuilder</code> is a mutable sequence of characters, allowing modification of strings without creating new objects. It is more efficient than <code>String</code> for concatenating multiple strings.</p> </li> <li> <p>Common Methods:</p> <ul> <li><code>append()</code>: Adds a string to the end.</li> <li><code>insert()</code>: Inserts a string at a specified position.</li> <li><code>delete()</code>: Removes a substring within a specified range.</li> <li><code>deleteCharAt()</code>: Removes the character at a specified index.</li> <li><code>reverse()</code>: Reverses the character sequence.</li> <li><code>replace()</code>: Replaces a substring with another string.</li> <li><code>length()</code>: Returns the length of the character sequence.</li> </ul> </li> <li> <p>Advantages: Using <code>StringBuilder</code> reduces memory usage and improves performance in scenarios with frequent string modifications.</p> </li> <li> <p>Resources: TutorialKart: Java StringBuilder</p> </li> </ul>  String related questions to ask during interviews:  <pre><code>1. Are there specific characters to consider (e.g., special characters, whitespace)?\n2. Is the string case-sensitive?\n3. What are the time and space complexity requirements?\n4. How large can the input string be?\n5. Are there limitations on operations I can use (e.g., no built-in string functions)?\n6. Can I modify the original string, or do I need to return a new string?\n7. Should the output maintain the order of characters from the original string?\n8. Are there multiple ways to solve this problem, or is there a preferred method?\n</code></pre>"},{"location":"Index8/","title":"Resources:","text":""},{"location":"Index8/#youtube","title":"YouTube","text":"<p>Greg Hoggs Hello Interview Design Gurus</p> <p>https://www.cs.usfca.edu/~galles/visualization/Algorithms.html https://csvistool.com/ Abdul Bari YT channel algomap.io https://www.coursera.org/learn/algorithms-part1?action=enroll&amp;authMode=signup&amp;utm_source=mobile</p>"},{"location":"Index8/#visualization-tools","title":"Visualization Tools:","text":"<ul> <li>VisuAlgo</li> <li>csvistool</li> </ul>"},{"location":"Index8/#sites","title":"Sites:","text":"<ul> <li>LeetCode</li> </ul>"},{"location":"Index8/#books","title":"Books:","text":""},{"location":"Index8/#coding-sites","title":"Coding Sites:","text":""},{"location":"Index8/#interview-prep","title":"Interview Prep:","text":"<p>Reverse-Interview</p>"},{"location":"index2/","title":"Blind 75","text":""},{"location":"index2/#arrays","title":"Arrays","text":""},{"location":"index2/#two-sum","title":"Two Sum","text":"HintsSolutionsResources <pre><code>//Use a HashMap to store numbers and their indices.\n//For each number in the array, compute its complement to reach the target\n//Check if the complement is in the HashMap\n//If yes, return the current index and the index of the complement\n//If no, add the number and its index to the HashMap\n</code></pre> <pre><code>    if (nums == null || nums.length &lt; 2) {\n    throw new IllegalArgumentException(\"Invalid input array\");\n    }\n    HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();\n    int[] result = new int[2];\n    for (int i = 0; i &lt; nums.length; i++) {\n    int complement = target - nums[i];\n    if (map.containsKey(complement)) {\n    result[0] = i;\n    result[1] = map.get(complement);\n    return result;\n    }\n    map.put(nums[i], i);\n    }\n</code></pre> Summary <p>To find two numbers in an array that add up to a target, use a HashMap for quick lookups. As you iterate through the array, calculate the complement needed to reach the target for each number. Check if this complement is already in the HashMap. If it is, return the indices of the current number and the complement. If not, store the current number and its index in the HashMap for future reference. This method allows you to find the solution efficiently in one pass through the array.</p>"},{"location":"index2/#best-time-to-buy-and-sell-stock","title":"Best Time to Buy and Sell Stock","text":"HintsSolutionsResources <pre><code>//Track the lowest price while iterating through the prices.\n//Calculate the profit by subtracting the tracked minimum price from each current price.\n</code></pre> <pre><code>        int minprice = Integer.MAX_VALUE;\n        int maxprofit = 0;\n        for (int i = 0; i &lt; prices.length; i++) {\n            if (prices[i] &lt; minprice) {\n                minprice = prices[i];\n            } else if (prices[i] - minprice &gt; maxprofit) {\n                maxprofit = prices[i] - minprice;\n            }\n        }\n        return maxprofit;\n</code></pre> Summary <p>The new number is lower than the lowest point found so far, so you update it. The new number is higher than your low point so it is a possible solution and you calculate the difference to find the profit. If it's higher than your max profit found so far, update.  YouTube Resource </p>"},{"location":"index2/#contains-duplicate","title":"Contains Duplicate","text":"HintsSolutionsResources <pre><code>//Create a HashSet to store seen integers.\n//Loop through each integer in the array.\n//Try to add each integer to the HashSet.\n//If adding the integer returns false, return true (found a duplicate).\n//If the loop completes without finding duplicates, return false.\n</code></pre> <pre><code>    public boolean containsDuplicate(int[] nums) {\n    Set&lt;Integer&gt; set = new HashSet&lt;Integer&gt;();\n    for (int num : nums) {\n        if (set.contains(num)) {\n            return true;\n        }\n        set.add(num);\n    }\n    return false;\n    }\n</code></pre>"},{"location":"index2/#product-of-array-except-self","title":"Product of Array Except Self","text":"HintsSolutionsResources <pre><code>//Create prefixProducts, suffixProducts, and resultArray arrays.\n//Set prefixProducts[0] to 1 and suffixProducts[length-1] to 1.\n//Iterate from left to right, storing cumulative products in prefixProducts.\n//Iterate from right to left, storing cumulative products in suffixProducts.\n//Multiply corresponding elements of prefixProducts and suffixProducts to fill resultArray.\n//Return the final resultArray.\n</code></pre> <pre><code>    int length = nums.length;\n    int[] prefixProducts = new int[length];\n    prefixProducts[0] = 1;\n    int[] suffixProducts = new int[length];\n    suffixProducts[length - 1] = 1;\n    int[] resultArray = new int[length];\n\n    for (int i = 1; i &lt; length; i++) {\n        prefixProducts[i] = nums[i - 1] * prefixProducts[i - 1];  \n    }\n\n    for (int i = length - 2; i &gt;= 0; i--) {\n        suffixProducts[i] = nums[i + 1] * suffixProducts[i + 1];\n    }\n\n    for (int i = 0; i &lt; length; i++) {\n        resultArray[i] = prefixProducts[i] * suffixProducts[i];   \n    }\n\n    return resultArray;\n</code></pre> <ul> <li>YouTube</li> </ul>"},{"location":"index2/#maximum-subarray","title":"Maximum Subarray","text":"HintsSolutionsResources <pre><code>//Initialize Variables: Set maxSum to Integer.MIN_VALUE and currSum to 0.\n//Iterate Through the Array: Add each element to currSum.\n//Update maxSum: Set maxSum to the greater of maxSum and currSum.\n//Reset currSum if Negative: If currSum is less than 0, reset it to 0.\n//Return maxSum: After the loop, return maxSum.\n</code></pre> <pre><code>    int maxSum = Integer.MIN_VALUE;\n    int currSum = 0;\n    for(int i=0; i&lt;nums.length; i++) {\n        currSum += nums[i];\n        maxSum = Math.max(maxSum, currSum);\n        if (currSum &lt; 0) {\n            currSum = 0;\n        }\n    } return maxSum;\n</code></pre> <p> YouTube Link </p>"},{"location":"index2/#maximum-product-subarray","title":"Maximum Product Subarray","text":"HintsSolutionsResources <pre><code>//Initialization: Create prefix and suffix variables, initialize both to 1, and initialize result to 0.\n//Iteration: Loop through the array from 0 to n-1.\n//Reset Prefix and Suffix: If prefix or suffix is 0, reset it to 1.\n//Update Prefix and Suffix: Multiply prefix by nums[i] and suffix by nums[n-i-1].\n//Update Result: Use Math.max to set result to the maximum of result, prefix, and suffix.\n//Return Result: Cast result to int and return it.\n</code></pre> <pre><code>int n= nums.length;\ndouble prefix = 1;\ndouble suffix = 1;\ndouble result = 0;\nif(n == 1) return nums[0];\nfor (int i=0; i&lt;n; i++) {\n    if (prefix == 0) { prefix = 1;}\n    if (suffix == 0) { suffix = 1;}\n    prefix *= nums[i];\n    suffix *= nums[n-i-1];\n    result = Math.max(result, Math.max(prefix, suffix)); \n}\nreturn (int) result;\n</code></pre> <ul> <li> YouTube </li> </ul>"},{"location":"index2/#find-minimum-in-rotated-sorted-array","title":"Find Minimum in Rotated Sorted Array","text":"HintsSolutionsResources <pre><code>//Initialize Pointers: Set up left and right to cover the entire array.\n//Binary Search Loop: Narrow down the search range by repeatedly halving it.\n//Midpoint Calculation: Calculate the midpoint and compare it to the element at right to decide which half to search next.\n//Adjust Pointers: Move left or right based on the comparison to narrow the search range.\n//Return Result: When the loop ends, left points to the minimum value.\n</code></pre> <pre><code>    int left = 0;\n    int right = nums.length-1;\n    while (left&lt;right) {\n        int mid = (left+right)/2;\n        if (nums[mid] &gt; nums[right]) {\n            left = mid + 1; \n        } else {\n            right = mid;\n        }\n    } return nums[left];\n</code></pre> Summary <p>The midpoint calculation int mid = left + (right - left) / 2 is used in binary search to avoid potential integer overflow and ensure accurate results. When left and right are large, directly using (left + right) / 2 could lead to overflow, as their sum might exceed the maximum integer value. By calculating mid as left + (right - left) / 2, the difference right - left is smaller and less prone to overflow, and dividing by 2 ensures the result is within a safe range. Adding left then adjusts the midpoint correctly within the current search segment, ensuring precise calculations without risking overflow.</p>"},{"location":"index3/","title":"Top Interview 150","text":""},{"location":"index3/#arrays-and-strings","title":"Arrays and Strings","text":""},{"location":"index3/#merge-sorted-array","title":"Merge Sorted Array","text":"HintsSolutionsResources <pre><code>// Compare elements from the end of nums1 and nums2, and place the larger element at the end of nums1.\n// If there are remaining elements in nums2, copy them into nums1.\n// Set pointers to the end of the relevant parts of nums1 and nums2. Also make a pointer on the 'm' value to compare with nums2 values. Pointers at the end of nums1 helps to insert into the appropriate place in nums1.\n</code></pre> <pre><code>int i = m - 1;\nint j = n - 1;\nint k = m + n - 1;\n\nwhile (i &gt;= 0 &amp;&amp; j &gt;= 0) {\n  if (nums2[j] &gt; nums1[i]) {\n    nums1[k] = nums2[j];\n    j--;\n  } else {\n    nums1[k] = nums1[i];\n    i--;\n  }\n  k--;\n}\nwhile (j &gt;= 0) {\n  nums1[k] = nums2[j];\n  j--;\n  k--;\n}\n</code></pre> <ul> <li>YouTube</li> </ul> Summary <p>To solve the problem of merging two sorted arrays into one sorted array in-place, start by initializing three pointers: one for the end of the initialized part of the first array, one for the end of the second array, and one for the end of the total merged array. Compare the elements at the ends of both arrays and place the larger element at the end of the merged array, moving the respective pointer one position to the left. Repeat this process until one of the arrays is exhausted. If any elements remain in the second array, copy them into the first array.</p>"},{"location":"index3/#27-remove-element","title":"27. Remove Element","text":"HintsSolutionsResources <pre><code>// Initialize leftPointer to 0 and rightPointer to 0.\n// Traverse the array with rightPointer until it reaches the end of the array:\n// If nums[rightPointer] is equal to val, increment rightPointer to skip this element.\n// If nums[rightPointer] is not equal to val, assign nums[rightPointer] to nums[leftPointer], and increment both leftPointer and rightPointer.\n// Return leftPointer, which represents the new length of the array after removing the elements equal to val.\n</code></pre> <pre><code>int leftPointer = 0;\nint rightPointer = 0;\nwhile (rightPointer &lt; nums.length) {\n  if (nums[rightPointer] == val) {\n    rightPointer++;\n  } else {\n    nums[leftPointer] = nums[rightPointer];\n    leftPointer++;\n    rightPointer++;\n  }\n}\nreturn leftPointer;\n</code></pre> <ul> <li>YouTube</li> </ul> Summary <p>To solve the problem of removing all occurrences of a specified value from an array, initialize two pointers: leftPointer and rightPointer, both set to 0. Use a while loop to traverse the array with rightPointer. If nums[rightPointer] equals the specified value, increment rightPointer to skip it. If nums[rightPointer] is not the specified value, copy nums[rightPointer] to nums[leftPointer], then increment both leftPointer and rightPointer. Continue this process until rightPointer reaches the end of the array. The value of leftPointer at the end of the loop will indicate the number of elements that are not equal to the specified value. The array is modified in place, and the final value of leftPointer is returned as the result.</p>"},{"location":"index3/#26-remove-duplicates-from-sorted-array","title":"26. Remove Duplicates from Sorted Array","text":"HintsSolutionsResources <pre><code>// Initialize leftPointer to 1 and rightPointer to 1.\n// Traverse the array with rightPointer until it reaches the end of the array.\n// If nums[rightPointer] is equal to nums[rightPointer - 1], increment rightPointer to skip this element.\n// If nums[rightPointer] is not equal to nums[rightPointer - 1], assign nums[rightPointer] to nums[leftPointer], and increment both leftPointer and rightPointer.\n// Return leftPointer, which represents the new length of the array after removing duplicates.\n</code></pre> <pre><code>class Solution {\n  public int removeDuplicates(int[] nums) {\n    int leftPointer = 1;\n    int rightPointer = 1;\n    while (rightPointer &lt; nums.length) {\n      if (nums[rightPointer] == nums[rightPointer - 1]) {\n        rightPointer++;\n      } else {\n        nums[leftPointer] = nums[rightPointer];\n        leftPointer++;\n        rightPointer++;\n      }\n    }\n    return leftPointer;\n  }\n}\n</code></pre> <ul> <li>YouTube</li> </ul> Summary <p>To solve the problem of removing duplicates from a sorted array, initialize two pointers: <code>leftPointer</code> and <code>rightPointer</code>, both set to 1. Use a <code>while</code> loop to traverse the array with <code>rightPointer</code>. If <code>nums[rightPointer]</code> equals <code>nums[rightPointer - 1]</code>, increment <code>rightPointer</code> to skip it. If <code>nums[rightPointer]</code> is not equal to <code>nums[rightPointer - 1]</code>, copy <code>nums[rightPointer]</code> to <code>nums[leftPointer]</code>, then increment both <code>leftPointer</code> and <code>rightPointer</code>. Continue this process until <code>rightPointer</code> reaches the end of the array. The value of <code>leftPointer</code> at the end of the loop will indicate the number of unique elements. The array is modified in place, and the final value of <code>leftPointer</code> is returned as the result.</p>"},{"location":"index4/","title":"DSA Conceptual","text":""},{"location":"index4/#linkedlist","title":"LinkedList","text":"<p> One disadvantage of using arrays to store data is that arrays are static structures and therefore cannot be easily extended or reduced to fit the data set. Arrays are also expensive to maintain new insertions and deletions. </p> <p> A linked list is a linear, dynamic data structure where each node contains data and a reference to the next node. The list can grow or shrink as needed, with the head pointing to the first node, or null if the list is empty. The last node points to null. </p> <pre><code>\ngraph LR\n    head\n    A[\"4 | next\"] --&gt; B[\"15 | next \"]\n    B --&gt; C[\"7 | next \"]\n    C --&gt; D[\"1 | next \"]\n    D --&gt; E[NULL]\n\n    classDef noStroke fill:none,stroke:none;\n    class head,E noStroke;\n\n    classDef defaultStyle fill:none,stroke:#fff;\n    class A,B,C,D defaultStyle;\n</code></pre> <p>  Singly Linked List  </p> <p>Notes: To track the element, we need head node anda tail node. Last valid node with data stored is tail node. First node with data stored is head node.  We get information from a node and then go to the next node information it has until the node points to null.</p> <p>Operations in LinkedList:</p>"},{"location":"index4/#addfirst-o1","title":"addFirst - O(1)","text":"<p>Steps:</p> <ol> <li>Create a new node: <code>Node newNode = new Node(data);</code></li> <li>Point the next of the new node to the head: <code>newNode.next = head;</code></li> <li>Point the head to the new node: <code>head = newNode;</code></li> </ol> <pre><code>public void addFirst(int data) {\n    Node newNode = new Node(data);\n    if (head == null) {\n        head = tail = newNode;\n        return;\n    }\n    newNode.next = head;\n    head = newNode;\n}\n</code></pre>"},{"location":"index4/#addlast-o1","title":"addLast - O(1)","text":"<p>Steps:</p> <ol> <li>Create a new node: <code>Node newNode = new Node(data);</code></li> <li>Point the next of the tail node to the newNode: <code>tail.next = newNode;</code></li> <li>Set the tail to the newNode: <code>tail = newNode;</code></li> </ol> <pre><code>public void addLast(int data) {\n    Node newNode = new Node(data);\n    if (head == null) {\n        head = tail = newNode;\n        return;\n    }\n    tail.next = newNode;\n    tail = newNode;\n}\n</code></pre>"},{"location":"index4/#print-a-linkedlist-on","title":"Print a linkedlist - O(N)","text":"<p>Steps:</p> <ol> <li>Initialize a temporary node to traverse the list: <code>Node temp = head;</code></li> <li>Check if the list is empty:</li> <li>If yes, print \"The list is empty\" and return.</li> <li>Traverse through the list:</li> <li>Print the data of the current node: <code>System.out.print(temp.data);</code></li> <li>Move to the next node: <code>temp = temp.next;</code></li> </ol> <p>Note: You are traversing through an existing list, so you don't need to create any new nodes. </p> <pre><code>public void printList() {\n    Node temp = head;\n    if (head == null) {\n        System.out.print(\"The list is empty\");\n        return;\n    }\n    while (temp != null) {\n        System.out.print(temp.data);\n        temp = temp.next;\n    }\n}\n</code></pre>"},{"location":"index4/#size-of-a-linkedlist-on","title":"Size of a linkedlist - O(N)","text":"<p>Steps:</p> <ol> <li>Initialize a temporary node to traverse the list: <code>Node temp = head;</code></li> <li>Initialize a variable to store the size of the list: <code>int size = 0;</code></li> <li>Traverse through the list, keep adding to the variables. </li> <li>Return the size of the list.</li> </ol> <pre><code>public int size() {\n    Node temp = head;\n    int size = 0;\n    while (temp != null) {\n        size++;\n        temp = temp.next;\n    }\n    return size;\n}\n</code></pre>"},{"location":"index4/#reverse-a-linked-list-on","title":"Reverse a linked list - O(N)","text":"<p>Steps:</p> <ol> <li>Initialize three nodes: <code>Node current = head, prev = null, next = null;</code></li> <li>Traverse through the list and do the following 4 steps:</li> <li><code>next = current.next;</code> Store the <code>current.next</code> node of the next node to preserve that value.</li> <li><code>current.next = prev;</code> Point the next of the current node to the previous node.</li> <li><code>prev = current;</code> Move the previous node to the current node.</li> <li><code>current = next;</code> Move the current node to the next node.</li> <li><code>head = prev;</code> Set the head to the previous node after done with the loop.</li> </ol> <pre><code>public void reverse() {\n    Node current = head, prev = null, next = null;\n    while (current != null) {\n        next = current.next;\n        current.next = prev;\n        prev = current;\n        current = next;\n    }\n    head = prev;\n}\n</code></pre>"},{"location":"index5/","title":"Index5","text":""},{"location":"index5/#interview-questions-to-ask","title":"Interview Questions to ask:","text":""},{"location":"index5/#technical-questions-to-ask-while-solving-technical-questions","title":"Technical questions to ask while solving technical questions.","text":""}]}